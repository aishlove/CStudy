#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{

	// 부호 있는 자료형에서 << 시프트 연산 하기

	char num1 = 113;	// 113 : 0111 0001
	char num2 = -15;	// -15 : 1111 0001
	char num3, num4, num5, num6;

	num3 = num1 << 2;	// num1의 비트 값을 왼쪽으로 2번 이동
	num4 = num2 << 2;	// num2의 비트 값을 왼쪽으로 2번 이동

	num5 = num1 << 4;	// num1의 비트 값을 왼쪽으로 4번 이동
	num6 = num2 << 4;	// num1의 비트 값을 왼쪽으로 4번 이동

	printf("%d\n", num3);	
	// -60: 1100 0100 : 부호 비트를 덮어쓰기 되므로 양수에서 음수가 됨
	printf("%d\n", num4);
	// -60: 1100 0100 : 이미 음수인 수는 계속 음수가 됨.

	printf("%d\n", num5);
	// 16 : 0001 0000 : 이미 양수인 수는 계속 양수가 됨.
	printf("%d\n", num6);
	// 16 : 0001 0000 : 부호 비트를 덮어쓰게 되므로 음수에서 양수가 됨.

	return 0;

	/* 
		1. 부호있는 자료형에서 첫 번째 비트가 0인 
		양수 0111 0001(113)을 왼쪽으로 2번 이동시키면
		1이 부호 비트를 덮어쓰게 된다. (오버플로우 상황)
		
		따라서 1100 0100(-60)이 되고,
		양수였던 수가 음수가 되어버린다.

		2. 이미 첫번째 비트가 1인 음수 1111 0001(-15)는 왼쪽으로 2번 이동시켜서
		부호를 덮어쓰더라도, 부호 비트는 바뀌지 않으므로
		계속 음수 1100 0100(-60) 이 됩니다.

		3. 비트를 왼쪽으로 좀 더 이동시켜서 0이 부호를 덮어쓰게 만들면,
		음수였던 수는 양수가 됩니다. 즉, 음수인 1111 0001(-15)를
		왼쪽으로 4번 이동시키면 1은 모두 사라지고,
		부호 비트에 0이 와서 양수 0001 0000(16)이 됩니다.

		4. 이미 첫번찌 비트가 0인 양수 0111 0001(113)을
		왼쪽으로 4번 이동시키면 앞의 1은 모두 사라지고,
		부호 비트에 0이 오므로 계속 양수 0001 0000(16)이 됩니다.


		부호 있는 자료형에서 부호를 왼쪽으로 이동시켰을 떄에는,
		브호 비트에 위치한 숫자에 따라 양수, 음수가 결정됩니다.

		>> 따라서, 부호 있는 자료형에서 시프트 연산을 할때에는
		의도치 않은 결과가 나올 수 있으므로, 항상 부호비트를 생각해야 합니다.


	*/
}