
[ 배열 vs 동적배열 vs 연결리스트 ] 

실생활 문제를 해결하고 도움을 주기 위해 발달한 항문이기 떄문에, 실습하고 하는게 훨씬 오래 기억에 남는다.

배열 :  int[] roomList;
- 사용할 방 개수를 고정해서 계약하고 (절대 변경 불가)
- 연속된 방으로 배정 받아 사용한다.

	장점 : 연속된 방 (친구들끼리 놀때 바로 옆방이니까 멀리 갈필요도 없고 편할거다.)
	단점 : 방을 추가 / 축소함이 불가능하다. 

	방을 세개밖에 못예약했기 떄문에 친구 못받아준다.
	친구가 가버려도 빈방으로 그냥 놔둬야 한다.
	> 유동적으로 상황에 맞춰 사용할 수 없는게 불편하다.


동적배열 :	List<int> roomList= new List<int>;
- 사용할 방 개수를 유동적으로 계약한다. (배열이 개선된 부분)
- 연속된 방으로 배정받아 사용한다. (배열과 동일)

	문제점 : 호텔에서 만약 다른 방에 사람이 들어와있어서 연속으로 못쓴다... 그럼 이사를 하면 된다. 다른 4열이 붙어있는 곳으로. 하지만 이사 비용은 어떻게하지? (부담)
		>> 어떻게든 이사 비용을 줄이려고 해야 한다는 점이 핵심이 되겠다.
		>> 이사를 한번 더 가야된다고 하면 열받아서 집에 갈 기세가 될거다... 결국 이사 횟수가 문제가 되는 것.

	동적배열 할당 정책
	- 실제로 사용할 방보다 많이, 여유분을 두고 (대략 1.5~2배) 예약한다.
	- 이사 횟수를 최소화한다.


	장점 : 유동적인 계약 (방 추가 예약으로 이사 횟수 최소화)
	단점 : 중간 삽입 / 삭제가 어렵다.
		>> 호텔에서 여섯명의 친구들이 오붓하게 놀고있었다. 놀다보니까 한 친구가 집에 그냥 가버렸다. 근데 동적배열의 특징은 연속된 방을 사용해야 된다는게 문제다.
		>> 어쩔 수 없이 뒤에 있던 방 친구들이 다시 이사를 가서 빈칸을 없애야 한다.
		>> 중간에 친구가 놀러와도 문제다. 뒤로 물러나야 되므로.


연결리스트 :   LinkedList<int> roomList = new LinkedList<int>;

- 연속되지 않은 방을 사용할 수 있다.

	장점 : 중간 추가 / 삭제 이점 (유일한 장점이다...)
	단점 : N번째 방을 바로 찾을수가 없음. (임의접근 Random Access 불가.)